use crate::{cli::Cli, load, validate, generate, exec};
use crate::model::ValidateSpec;
use anyhow::{Context, Result};
use std::{fs, path::PathBuf, process::Command};

pub fn cmd_build(cli: &Cli) -> Result<()> {
    let loaded = load::load_all(&cli.config_dir)?;
    validate::validate_model(&loaded.domains, &loaded.upstreams, &loaded.policies, &loaded.defaults)?;

    let yaml_value = generate::generate_envoy_yaml(&loaded)?;

    fs::create_dir_all(&cli.out_dir)?;
    let out_path = cli.out_dir.join("envoy.generated.yaml");

    let header = format!(
        "# =============================================================================\n\
         # AUTO-GENERATED by envoyctl - DO NOT EDIT\n\
         # =============================================================================\n\
         # Source: {}\n\
         # Output: {}\n\
         # Generated: {}\n\
         # =============================================================================\n\n",
        cli.config_dir.display(),
        out_path.display(),
        chrono::Local::now().format("%Y-%m-%d %H:%M:%S"),
    );

    let body = serde_yaml::to_string(&yaml_value)?;

    // Add section comments for better readability
    let body = add_section_comments(&body, &loaded);

    fs::write(&out_path, format!("{header}{body}"))?;

    println!("Wrote {}", out_path.display());
    Ok(())
}

/// Add section comments to the generated YAML for better readability
fn add_section_comments(yaml: &str, loaded: &load::Loaded) -> String {
    let mut result = String::new();

    for line in yaml.lines() {
        // Add comment before admin section
        if line == "admin:" {
            result.push_str("# -----------------------------------------------------------------------------\n");
            result.push_str("# Admin Interface\n");
            result.push_str("# -----------------------------------------------------------------------------\n");
        }

        // Add comment before static_resources
        if line == "static_resources:" {
            result.push_str("\n# -----------------------------------------------------------------------------\n");
            result.push_str("# Static Resources (Listeners & Clusters)\n");
            result.push_str("# -----------------------------------------------------------------------------\n");
        }

        // Add comment before HTTP listener
        if line == "  - name: http_listener" {
            result.push_str("    # -----------------------------------------------------------------\n");
            result.push_str("    # HTTP Listener (Port 80)\n");
            result.push_str(&format!("    # Default upstream: {}\n", loaded.defaults.http_default_upstream));
            result.push_str("    # -----------------------------------------------------------------\n");
        }

        // Add comment before HTTPS SNI listener
        if line == "  - name: https_sni_listener" {
            result.push_str("\n    # -----------------------------------------------------------------\n");
            result.push_str("    # HTTPS SNI Listener (Port 443)\n");
            result.push_str("    # TLS termination for configured domains, passthrough for others\n");

            // List domains with TLS termination
            let terminate_domains: Vec<_> = loaded.domains.iter()
                .filter(|d| d.mode == "terminate_https_443")
                .collect();

            if !terminate_domains.is_empty() {
                result.push_str("    # TLS Termination:\n");
                for domain in &terminate_domains {
                    let upstream = domain.routes.first()
                        .map(|r| r.to_upstream.as_str())
                        .unwrap_or("(no routes)");
                    result.push_str(&format!("    #   - {} -> {}\n", domain.domain, upstream));
                }
            }

            result.push_str(&format!("    # Default passthrough: {}\n", loaded.defaults.tls_passthrough_upstream));
            result.push_str("    # -----------------------------------------------------------------\n");
        }

        // Add comment before clusters section
        if line == "  clusters:" {
            result.push_str("\n  # ---------------------------------------------------------------------------\n");
            result.push_str("  # Clusters (Backend Services)\n");
            result.push_str("  # ---------------------------------------------------------------------------\n");
        }

        result.push_str(line);
        result.push('\n');
    }

    result
}

pub fn cmd_validate(cli: &Cli) -> Result<()> {
    cmd_build(cli)?;
    let loaded = load::load_all(&cli.config_dir)?;
    let out_path = cli.out_dir.join("envoy.generated.yaml");
    run_envoy_validate(cli, &loaded.validate, &out_path)?;
    println!("Validation OK");
    Ok(())
}

fn run_envoy_validate(cli: &Cli, validate: &ValidateSpec, generated: &PathBuf) -> Result<()> {
    match validate {
        ValidateSpec::DockerExec { container, config_path } => {
            // docker exec -it <container> envoy --mode validate -c <config_path>
            // Note: We need to copy the generated config to the container's config path first,
            // or validate against the existing config in the container.
            // For validation, we validate the generated file by mounting it.
            let abs = generated.canonicalize().context("canonicalize generated path")?;

            // First, copy the generated config to the container
            let mut copy_cmd = Command::new("docker");
            copy_cmd.args(["cp"])
                .arg(abs.to_str().unwrap())
                .arg(format!("{}:{}", container, config_path));
            exec::run(&mut copy_cmd).context("docker cp config to container")?;

            // Then validate inside the container
            let mut cmd = Command::new("docker");
            cmd.args(["exec", container, "envoy", "--mode", "validate", "-c", config_path]);
            exec::run(&mut cmd).context("envoy validate (docker exec)")?;
        }
        ValidateSpec::Native { user, bin, config_path } => {
            // sudo -u <user> <bin> --mode validate -c <config_path>
            // First copy generated config to the target path
            let abs = generated.canonicalize().context("canonicalize generated path")?;

            // Copy the generated file to the config path (requires sudo)
            let mut copy_cmd = Command::new("sudo");
            copy_cmd.args(["cp", abs.to_str().unwrap(), config_path]);
            exec::run(&mut copy_cmd).context("sudo cp config")?;

            // Set ownership to envoy user
            let mut chown_cmd = Command::new("sudo");
            chown_cmd.args(["chown", &format!("{}:{}", user, user), config_path]);
            exec::run(&mut chown_cmd).context("sudo chown config")?;

            // Validate as the envoy user
            let envoy_bin = cli.envoy_bin.clone().unwrap_or_else(|| bin.clone());
            let mut cmd = Command::new("sudo");
            cmd.args(["-u", user, &envoy_bin, "--mode", "validate", "-c", config_path]);
            exec::run(&mut cmd).context("envoy validate (native/sudo)")?;
        }
        ValidateSpec::DockerImage { image } => {
            // docker run --rm -v <generated>:/cfg.yaml:ro <image> envoy --mode validate -c /cfg.yaml
            let abs = generated.canonicalize().context("canonicalize generated path")?;
            let mut cmd = Command::new("docker");
            cmd.args(["run", "--rm", "-v"])
                .arg(format!("{}:/cfg.yaml:ro", abs.display()))
                .arg(image)
                .args(["envoy", "--mode", "validate", "-c", "/cfg.yaml"]);
            exec::run(&mut cmd).context("envoy validate (docker image)")?;
        }
    }
    Ok(())
}

/// Atomically install a file by writing to a temp file and renaming
#[allow(dead_code)]
fn atomic_install(src: &PathBuf, dst: &PathBuf) -> Result<()> {
    let dir = dst.parent().context("install path has no parent")?;
    fs::create_dir_all(dir)?;
    let tmp = dir.join(format!(".{}.tmp", dst.file_name().unwrap().to_string_lossy()));
    fs::copy(src, &tmp)?;
    fs::rename(&tmp, dst)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cli::Cli;
    use std::fs;
    use std::path::PathBuf;
    use tempfile::TempDir;

    #[test]
    fn test_atomic_install() {
        let temp_dir = TempDir::new().unwrap();
        let src_path = temp_dir.path().join("source.yaml");
        let dst_path = temp_dir.path().join("destination.yaml");

        // Create source file
        fs::write(&src_path, "test content").unwrap();

        // Perform atomic install
        let result = atomic_install(&src_path, &dst_path);
        assert!(result.is_ok());

        // Verify destination file exists and has correct content
        assert!(dst_path.exists());
        let content = fs::read_to_string(&dst_path).unwrap();
        assert_eq!(content, "test content");
    }

    #[test]
    fn test_atomic_install_dst_dir_created() {
        let temp_dir = TempDir::new().unwrap();
        let src_path = temp_dir.path().join("source.yaml");
        let dst_dir = temp_dir.path().join("subdir");
        let dst_path = dst_dir.join("destination.yaml");

        // Create source file but not destination directory
        fs::write(&src_path, "test content").unwrap();

        // Perform atomic install - should create dst directory
        let result = atomic_install(&src_path, &dst_path);
        assert!(result.is_ok());

        // Verify destination file exists in created subdirectory
        assert!(dst_path.exists());
        let content = fs::read_to_string(&dst_path).unwrap();
        assert_eq!(content, "test content");
    }

    #[test]
    fn test_cmd_build_success() {
        // Create a temporary config directory structure
        let temp_dir = TempDir::new().unwrap();
        let config_dir = temp_dir.path().join("config");
        let out_dir = temp_dir.path().join("out");

        // Create necessary directory structure
        fs::create_dir_all(config_dir.join("common")).unwrap();
        fs::create_dir_all(config_dir.join("domains")).unwrap();
        fs::create_dir_all(config_dir.join("upstreams")).unwrap();
        fs::create_dir_all(config_dir.join("policies")).unwrap();

        // Create common config files
        fs::write(config_dir.join("common/admin.yaml"), "address: \"0.0.0.0\"\nport: 9901").unwrap();
        fs::write(config_dir.join("common/defaults.yaml"), "route_timeout: \"60s\"\nhttp_default_upstream: \"default_backend\"\ntls_passthrough_upstream: \"default_tls\"").unwrap();
        fs::write(config_dir.join("common/access_log.yaml"), "type: \"stdout\"\npath: \"/dev/stdout\"").unwrap();
        fs::write(config_dir.join("common/runtime.yaml"), r#"validate: {type: "native"}
restart: {type: "docker_restart", container: "envoy"}
"#).unwrap();

        // Create policies file
        fs::write(config_dir.join("policies/ratelimits.yaml"), "").unwrap();

        // Create a default backend upstream (required by defaults)
        fs::write(config_dir.join("upstreams/default_backend.yaml"), r#"
name: "default_backend"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8080
"#).unwrap();

        // Create a default TLS backend upstream (required by defaults)
        fs::write(config_dir.join("upstreams/default_tls.yaml"), r#"
name: "default_tls"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8443
"#).unwrap();

        // Create CLI instance
        let cli = Cli {
            config_dir,
            out_dir,
            install_path: PathBuf::from("/tmp/test.yaml"),
            envoy_bin: None,
            cmd: crate::cli::Command::Build,
        };

        // Test cmd_build - this should create the output file
        let result = cmd_build(&cli);
        assert!(result.is_ok());

        // Verify output file was created
        let out_path = cli.out_dir.join("envoy.generated.yaml");
        assert!(out_path.exists());
    }

    #[test]
    fn test_cmd_validate_with_invalid_config() {
        // Create a temporary config directory structure with invalid config
        let temp_dir = TempDir::new().unwrap();
        let config_dir = temp_dir.path().join("config");
        let out_dir = temp_dir.path().join("out");

        // Create necessary directory structure
        fs::create_dir_all(config_dir.join("common")).unwrap();
        fs::create_dir_all(config_dir.join("domains")).unwrap();
        fs::create_dir_all(config_dir.join("upstreams")).unwrap();
        fs::create_dir_all(config_dir.join("policies")).unwrap();

        // Create common config files
        fs::write(config_dir.join("common/admin.yaml"), "address: \"0.0.0.0\"\nport: 9901").unwrap();
        fs::write(config_dir.join("common/defaults.yaml"), "route_timeout: \"60s\"").unwrap();
        fs::write(config_dir.join("common/access_log.yaml"), "type: \"stdout\"\npath: \"/dev/stdout\"").unwrap();
        fs::write(config_dir.join("common/runtime.yaml"), r#"validate:
  type: "native"
  user: "envoy"
  bin: "envoy"
  config_path: "/etc/envoy/envoy.yaml"
"#).unwrap();

        // Create policies file
        fs::write(config_dir.join("policies/ratelimits.yaml"), "").unwrap();

        // Create a domain that references a non-existent upstream (invalid)
        fs::write(config_dir.join("domains/test.yaml"), r#"
domain: "example.com"
mode: "terminate_https_443"
tls:
  cert_chain: "/path/to/cert"
  private_key: "/path/to/key"
routes:
  - match: { prefix: "/api" }
    to_upstream: "nonexistent_backend"  # This doesn't exist
"#).unwrap();

        // Create CLI instance
        let cli = Cli {
            config_dir,
            out_dir,
            install_path: PathBuf::from("/tmp/test.yaml"),
            envoy_bin: None,
            cmd: crate::cli::Command::Validate,
        };

        // Test cmd_validate - this should fail during validation
        let result = cmd_validate(&cli);
        assert!(result.is_err());
    }
}
