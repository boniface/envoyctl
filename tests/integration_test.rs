use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

#[test]
fn test_full_workflow_build_validate() {
    // Create a temporary directory for our test
    let temp_dir = TempDir::new().unwrap();
    let config_dir = temp_dir.path().join("config");
    let out_dir = temp_dir.path().join("out");

    // Create the config directory structure
    fs::create_dir_all(config_dir.join("common")).unwrap();
    fs::create_dir_all(config_dir.join("domains")).unwrap();
    fs::create_dir_all(config_dir.join("upstreams")).unwrap();
    fs::create_dir_all(config_dir.join("policies")).unwrap();

    // Create common config files
    fs::write(
        config_dir.join("common/admin.yaml"),
        r#"
address: "0.0.0.0"
port: 9901
"#
    ).unwrap();

    fs::write(
        config_dir.join("common/defaults.yaml"),
        r#"
route_timeout: "60s"
http_default_upstream: "default_http"
tls_passthrough_upstream: "default_tls"
"#
    ).unwrap();

    fs::write(
        config_dir.join("common/access_log.yaml"),
        r#"
type: "stdout"
path: "/dev/stdout"
"#
    ).unwrap();

    fs::write(
        config_dir.join("common/runtime.yaml"),
        r#"
validate:
  type: "native"
restart:
  type: "docker_restart"
  container: "envoy"
"#
    ).unwrap();

    // Create policies file
    fs::write(
        config_dir.join("policies/ratelimits.yaml"),
        r#"
local_ratelimits: {}
"#
    ).unwrap();

    // Create an upstream
    fs::write(
        config_dir.join("upstreams/default_http.yaml"),
        r#"
name: "default_http"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8080
"#
    ).unwrap();

    fs::write(
        config_dir.join("upstreams/default_tls.yaml"),
        r#"
name: "default_tls"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8443
"#
    ).unwrap();

    // Create a domain
    fs::write(
        config_dir.join("domains/example.com.yaml"),
        r#"
domain: "example.com"
mode: "terminate_https_443"
tls:
  cert_chain: "/etc/ssl/certs/example.com.crt"
  private_key: "/etc/ssl/private/example.com.key"
routes:
  - match: { prefix: "/" }
    to_upstream: "default_http"
"#
    ).unwrap();

    // Now test the full workflow using the actual functions
    let cli = envoyctl::cli::Cli {
        config_dir,
        out_dir: out_dir.clone(),
        install_path: PathBuf::from("/tmp/test.yaml"),
        envoy_bin: None,
        cmd: envoyctl::cli::Command::Build,
    };

    // Test build command
    let result = envoyctl::apply::cmd_build(&cli);
    assert!(result.is_ok());

    // Verify output file was created
    let output_file = out_dir.join("envoy.generated.yaml");
    assert!(output_file.exists());

    // Check that the output file contains expected content
    let content = fs::read_to_string(&output_file).unwrap();
    assert!(content.contains("AUTO-GENERATED by envoyctl"));
    assert!(content.contains("static_resources"));
    assert!(content.contains("listeners"));
    assert!(content.contains("clusters"));
}