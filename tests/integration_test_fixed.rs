use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;

#[test]
fn test_full_workflow_build_validate() {
    // Create a temporary directory for our test
    let temp_dir = TempDir::new().unwrap();
    let config_dir = temp_dir.path().join("config");
    let out_dir = temp_dir.path().join("out");
    
    // Create the config directory structure
    fs::create_dir_all(config_dir.join("common")).unwrap();
    fs::create_dir_all(config_dir.join("domains")).unwrap();
    fs::create_dir_all(config_dir.join("upstreams")).unwrap();
    fs::create_dir_all(config_dir.join("policies")).unwrap();
    
    // Create common config files
    fs::write(
        config_dir.join("common/admin.yaml"),
        r#"
address: "0.0.0.0"
port: 9901
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/defaults.yaml"),
        r#"
route_timeout: "60s"
http_default_upstream: "default_http"
tls_passthrough_upstream: "default_tls"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/access_log.yaml"),
        r#"
type: "stdout"
path: "/dev/stdout"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/runtime.yaml"),
        r#"
validate:
  type: "native"
restart:
  type: "docker_restart"
  container: "envoy"
"#
    ).unwrap();
    
    // Create policies file
    fs::write(
        config_dir.join("policies/ratelimits.yaml"),
        r#"
local_ratelimits: {}
"#
    ).unwrap();
    
    // Create an upstream
    fs::write(
        config_dir.join("upstreams/default_http.yaml"),
        r#"
name: "default_http"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8080
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("upstreams/default_tls.yaml"),
        r#"
name: "default_tls"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8443
"#
    ).unwrap();
    
    // Create a domain
    fs::write(
        config_dir.join("domains/example.com.yaml"),
        r#"
domain: "example.com"
mode: "terminate_https_443"
tls:
  cert_chain: "/etc/ssl/certs/example.com.crt"
  private_key: "/etc/ssl/private/example.com.key"
routes:
  - match: { prefix: "/" }
    to_upstream: "default_http"
"#
    ).unwrap();
    
    // Now test the full workflow using the actual functions
    let cli = envoyctl::cli::Cli {
        config_dir,
        out_dir: out_dir.clone(),
        install_path: PathBuf::from("/tmp/test.yaml"),
        envoy_bin: None,
        cmd: envoyctl::cli::Command::Build,
    };
    
    // Test build command
    let result = envoyctl::apply::cmd_build(&cli);
    assert!(result.is_ok());
    
    // Verify output file was created
    let output_file = out_dir.join("envoy.generated.yaml");
    assert!(output_file.exists());
    
    // Check that the output file contains expected content
    let content = fs::read_to_string(&output_file).unwrap();
    assert!(content.contains("AUTO-GENERATED by envoyctl"));
    assert!(content.contains("static_resources"));
    assert!(content.contains("listeners"));
    assert!(content.contains("clusters"));
}

#[test]
fn test_load_and_validate_functionality() {
    // Create a temporary directory for our test
    let temp_dir = TempDir::new().unwrap();
    let config_dir = temp_dir.path().join("config");
    
    // Create the config directory structure
    fs::create_dir_all(config_dir.join("common")).unwrap();
    fs::create_dir_all(config_dir.join("domains")).unwrap();
    fs::create_dir_all(config_dir.join("upstreams")).unwrap();
    fs::create_dir_all(config_dir.join("policies")).unwrap();
    
    // Create config files with valid configuration
    fs::write(
        config_dir.join("common/admin.yaml"),
        r#"
address: "0.0.0.0"
port: 9901
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/defaults.yaml"),
        r#"
route_timeout: "60s"
http_default_upstream: "api_backend"
tls_passthrough_upstream: "default_tls"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/access_log.yaml"),
        r#"
type: "stdout"
path: "/dev/stdout"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/runtime.yaml"),
        r#"
validate:
  type: "native"
restart:
  type: "docker_restart"
  container: "envoy"
"#
    ).unwrap();
    
    // Create policies file
    fs::write(
        config_dir.join("policies/ratelimits.yaml"),
        r#"
local_ratelimits: {}
"#
    ).unwrap();
    
    // Create upstreams
    fs::write(
        config_dir.join("upstreams/api_backend.yaml"),
        r#"
name: "api_backend"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8080
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("upstreams/default_tls.yaml"),
        r#"
name: "default_tls"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8443
"#
    ).unwrap();
    
    // Create a domain with TLS
    fs::write(
        config_dir.join("domains/api.example.com.yaml"),
        r#"
domain: "api.example.com"
mode: "terminate_https_443"
tls:
  cert_chain: "/etc/ssl/certs/api.example.com.crt"
  private_key: "/etc/ssl/private/api.example.com.key"
routes:
  - match: { prefix: "/api/v1" }
    to_upstream: "api_backend"
    timeout: "30s"
"#
    ).unwrap();
    
    // Test loading and validation
    let loaded = envoyctl::load::load_all(&config_dir).expect("Failed to load config");
    
    // Validate the loaded configuration
    let validation_result = envoyctl::validate::validate_model(
        &loaded.domains,
        &loaded.upstreams,
        &loaded.policies,
        &loaded.defaults
    );
    assert!(validation_result.is_ok());
    
    // Test that we loaded the expected data
    assert_eq!(loaded.admin.port, 9901);
    assert_eq!(loaded.defaults.route_timeout, "60s");
    assert_eq!(loaded.access_log.r#type, "stdout");
    assert_eq!(loaded.domains.len(), 1);
    assert_eq!(loaded.upstreams.len(), 2);
    assert!(loaded.policies.local_ratelimits.is_empty());
    
    // Check domain details
    let domain = &loaded.domains[0];
    assert_eq!(domain.domain, "api.example.com");
    assert_eq!(domain.mode, "terminate_https_443");
    assert!(domain.tls.is_some());
    assert_eq!(domain.routes.len(), 1);
    assert_eq!(domain.routes[0].to_upstream, "api_backend");
    
    // Check upstream details
    let api_backend = loaded.upstreams.iter()
        .find(|u| u.name == "api_backend")
        .expect("api_backend upstream should exist");
    assert_eq!(api_backend.endpoints.len(), 1);
    assert_eq!(api_backend.endpoints[0].address, "127.0.0.1");
    assert_eq!(api_backend.endpoints[0].port, 8080);
}

#[test]
fn test_validation_with_invalid_config() {
    // Create a temporary directory for our test with invalid config
    let temp_dir = TempDir::new().unwrap();
    let config_dir = temp_dir.path().join("config");
    
    // Create the config directory structure
    fs::create_dir_all(config_dir.join("common")).unwrap();
    fs::create_dir_all(config_dir.join("domains")).unwrap();
    fs::create_dir_all(config_dir.join("upstreams")).unwrap();
    fs::create_dir_all(config_dir.join("policies")).unwrap();
    
    // Create config files with valid base configuration
    fs::write(
        config_dir.join("common/admin.yaml"),
        r#"
address: "0.0.0.0"
port: 9901
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/defaults.yaml"),
        r#"
route_timeout: "60s"
http_default_upstream: "nonexistent_http"  # This doesn't exist
tls_passthrough_upstream: "default_tls"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/access_log.yaml"),
        r#"
type: "stdout"
path: "/dev/stdout"
"#
    ).unwrap();
    
    fs::write(
        config_dir.join("common/runtime.yaml"),
        r#"
validate:
  type: "native"
restart:
  type: "docker_restart"
  container: "envoy"
"#
    ).unwrap();
    
    // Create policies file
    fs::write(
        config_dir.join("policies/ratelimits.yaml"),
        r#"
local_ratelimits: {}
"#
    ).unwrap();
    
    // Create only one upstream (not the one referenced in defaults)
    fs::write(
        config_dir.join("upstreams/default_tls.yaml"),
        r#"
name: "default_tls"
connect_timeout: "5s"
type: "STATIC"
lb_policy: "ROUND_ROBIN"
endpoints:
  - address: "127.0.0.1"
    port: 8443
"#
    ).unwrap();
    
    // Create a domain that references a non-existent upstream
    fs::write(
        config_dir.join("domains/example.com.yaml"),
        r#"
domain: "example.com"
mode: "terminate_https_443"
tls:
  cert_chain: "/etc/ssl/certs/example.com.crt"
  private_key: "/etc/ssl/private/example.com.key"
routes:
  - match: { prefix: "/api" }
    to_upstream: "nonexistent_backend"  # This doesn't exist
"#
    ).unwrap();
    
    // Load the configuration
    let loaded = envoyctl::load::load_all(&config_dir).expect("Failed to load config");
    
    // Validation should fail because:
    // 1. http_default_upstream "nonexistent_http" doesn't exist
    // 2. route references "nonexistent_backend" which doesn't exist
    let validation_result = envoyctl::validate::validate_model(
        &loaded.domains,
        &loaded.upstreams,
        &loaded.policies,
        &loaded.defaults
    );
    
    assert!(validation_result.is_err());
    
    let error_msg = validation_result.unwrap_err().to_string();
    assert!(error_msg.contains("http_default_upstream") || error_msg.contains("nonexistent_backend"));
}